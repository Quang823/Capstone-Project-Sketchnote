import React, { createContext, useContext, useState, useEffect } from "react";
import AsyncStorage from "@react-native-async-storage/async-storage";

const CartContext = createContext();
export const useCart = () => useContext(CartContext);

export const CartProvider = ({ children }) => {
  const [cart, setCart] = useState([]);

  // üîπ Load cart t·ª´ AsyncStorage khi app kh·ªüi ƒë·ªông
  useEffect(() => {
    (async () => {
      try {
        const storedCart = await AsyncStorage.getItem("cart");
        if (storedCart) {
          setCart(JSON.parse(storedCart));
          console.log("‚úÖ Cart loaded from storage");
          console.log(storedCart);
        }
      } catch (error) {
        console.error("‚ùå Error loading cart:", error);
      }
    })();
  }, []);

  // üîπ L∆∞u cart m·ªói khi c√≥ thay ƒë·ªïi
  useEffect(() => {
    (async () => {
      try {
        await AsyncStorage.setItem("cart", JSON.stringify(cart));
        console.log(cart);
        console.log("üíæ Cart saved to storage");
      } catch (error) {
        console.error("‚ùå Error saving cart:", error);
      }
    })();
  }, [cart]);

  // ‚úÖ Th√™m v√†o gi·ªè - L∆∞u ƒë·∫ßy ƒë·ªß th√¥ng tin
const addToCart = (item) => {
  setCart((prevCart) => {
    const existing = prevCart.find((p) => p.id === item.id);

    if (existing) {
      return prevCart.map((p) =>
        p.id === item.id ? { ...p, quantity: p.quantity + 1 } : p
      );
    }

    // Chu·∫©n h√≥a th√¥ng tin designer
    const designerData = item.designer
      ? {
          name:
            item.designer.name ||
            `${item.designer.firstName || ""} ${item.designer.lastName || ""}`.trim(),
          email: item.designer.email || "",
          avatarUrl: item.designer.avatarUrl || null,
        }
      : null;

    const newItem = {
      id: item.id,
      name: item.name,
      description: item.description || "",
      price: item.price,
      image: item.image || "",
      type: item.type || "OTHER",
      quantity: 1,
      designer: designerData,
      releaseDate: item.releaseDate || null,
      isActive: item.isActive !== undefined ? item.isActive : true,
    };

    return [...prevCart, newItem];
  });
};


  // ‚úÖ X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè
  const removeFromCart = (id) => {
    setCart((prevCart) => {
      const filtered = prevCart.filter((p) => p.id !== id);
   
      return filtered;
    });
  };

  // ‚úÖ C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
  const updateQuantity = (id, delta) => {
    setCart((prevCart) =>
      prevCart
        .map((p) => {
          if (p.id === id) {
            const newQuantity = p.quantity + delta;
            // N·∫øu s·ªë l∆∞·ª£ng = 0, x√≥a kh·ªèi gi·ªè
            if (newQuantity <= 0) {
              
              return null;
            }
          
            return { ...p, quantity: newQuantity };
          }
          return p;
        })
        .filter(Boolean) // Lo·∫°i b·ªè items c√≥ gi√° tr·ªã null
    );
  };

  // ‚úÖ X√≥a to√†n b·ªô gi·ªè h√†ng
  const clearCart = () => {
    setCart([]);
    console.log("üßπ Cart cleared");
  };

  // ‚úÖ T√≠nh t·ªïng gi√° tr·ªã gi·ªè h√†ng
  const getCartTotal = () => {
    return cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
  };

  // ‚úÖ ƒê·∫øm t·ªïng s·ªë s·∫£n ph·∫©m (theo quantity)
  const getCartItemCount = () => {
    return cart.reduce((sum, item) => sum + item.quantity, 0);
  };

  return (
    <CartContext.Provider
      value={{
        cart,
        addToCart,
        removeFromCart,
        updateQuantity,
        clearCart,
        getCartTotal,
        getCartItemCount,
      }}
    >
      {children}
    </CartContext.Provider>
  );
};